After reflecting on my own coding practices together with the principles presented in Clean Code, I have realized that my view on code quality is both practical and evolving. One major area of learning has been naming conventions. At first I believed that short and concise names, such as x or y, made the code appear more clean and “tight.” However, I now understand that such names do not always communicate the intention behind the variable or function. Meaningful and descriptive names not only make code executable, but also readable and self-explanatory. I have also recognized the risk of keeping temporary names, like dataTest or testArray, which might work during development but reduce clarity when left in the final codebase.

Another important aspect is the length and structure of functions. The literature suggests that functions should be extremely short, often only three to four lines. I find this somewhat unrealistic in practice, especially when writing coordinating functions or constructors. However, I do agree with the principle of “one function, one task,” as this keeps the focus clear. My experience with functions like passwordStrength showed me that sometimes rules are hard to follow strictly, and that practical solutions may break conventions. Therefore, I believe code quality comes not from absolute adherence to rules, but from thoughtful decision-making about when to follow them and when to adapt.

I have also reflected on arguments and reusability. The book emphasizes that more than two arguments increase cognitive load, which was surprising but also insightful. Looking at my own functions, I realize I sometimes write them too specific, which makes reuse difficult. This is an area where I clearly need improvment. However, even when not fully applied, the principle has made me more aware of how arguments influence clarity and maintainabillity.

In conclusion, my perspective on code quality has shifted from simply “making the code work” to making the code communicate its purpose. Quality is not about perfection but about continuous improvemnt. Clear names, well-structured functions, and the ability to adapt guidelines to real-world situations are, in my view, the most important aspects of writing good software. Therefore, I see code quality as an ongoing process where small refinments can have a large impact on how understandable and maintainable a project becomes.